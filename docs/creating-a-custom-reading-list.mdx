---
title: 'Engineering a Frictionless Reading List Workflow'
publishedAt: '2025-12-11'
summary: 'A transcript of our engineering discussion on how to streamline adding articles to a static reading list, exploring browser extensions, system integrations, and automation strategies.'
---

**Me**: I'm thinking about scoping out my reading list functionality a lot more.

Currently the flow is:
browse the web on chrome -> find a post to read (webpage) -> read it -> copy link -> paste into command `pnpm add-reading {link} {optional date}` to run this script `scripts/add-reading.js`.

You can see how this is tedious. Especially considering I want to be able to add a single sentence on my thoughts on the post, we can add this as a field in the reading json `data/reading.json`. What I really want is to explore a more efficient way of doing this.

What options can we explore for this?

**Antigravity**: To streamline your reading list workflow, we need to minimize context switching. Since you are on a Mac and already have a Next.js app running locally, we have some excellent options that can reduce this to a 2-second action.

Here are the three best approaches to explore:

### Option 1: The "Web-First" Approach (Bookmarklet + API Route)
**How it works:**
1. You drag a special "Add to Reading" link to your bookmarks bar.
2. When reading a post, you click the bookmark.
3. A simple prompt appears: *"Any thoughts?"*
4. You type your sentence and hit Enter.
5. The bookmarklet sends the URL and your thoughts to your running Next.js app (`localhost:3000`), which handles the scraping and file updating in the background.

*   **Pros:** Zero context switching (you stay in the browser), very easy to set up, reuses your existing scraping logic.
*   **Cons:** Requires your local dev server (`pnpm dev`) to be running.

### Option 2: The "System-Native" Approach (Raycast / Alfred)
**How it works:**
1. You press a hotkey (e.g., `Cmd + Space` -> "Add Reading").
2. The script automatically grabs the URL from the active Chrome tab.
3. It asks you for "Thoughts".
4. It runs your `add-reading.js` script in the background.

*   **Pros:** extremely fast, keyboard-centric, feels like a native OS feature.
*   **Cons:** Requires Raycast (free) or Alfred (Powerpack).

### Option 3: The "CLI-Enhanced" Approach
**How it works:**
We modify your existing script to be interactive and smart.
1. You run `pnpm read`.
2. It automatically grabs the URL from your clipboard.
3. It asks: *"Thoughts?"*
4. You type and hit Enter.

*   **Pros:** Simple code change, no external tools.
*   **Cons:** Still requires opening the terminal.

**Recommendation**: I recommend **Option 1 (Bookmarklet)** if you want to stay in the flow of reading, or **Option 2 (Raycast)** if you are a keyboard power-user who loves system-wide tools.

**Me**: My thoughts on option 1:
My app will not always be running on next.js, it is a static site hosted on github pages for now but may move to a different domain. nevertheless it is not local. So wrong assumption.

I do like the idea of a custom link or a chrome extension so that it doesn't disturb my reading flow, maybe we could explore that. Especially if we wanted to make this widely available for other users and offer the full integration of a static reading list option on their blog that can be added to using a web first approach.

The question is how do we connect the two? The web extension + the blog reading list. Especially without overcomplicating it and having to create an API or a database to manage a static site!

"Any thoughts?" is a good prompt to appear and can be left blank.

Option 2:
I like option 2, I don't use Raycast currently however I have heard good things about it and have been considering the switch.
A hot key that asks "Any thoughts?" would be very useful for keyboard-centric users. However what would be the process for publishing this workflow? Also wouldn't it be limited to only mac users?

Option 3:
Not a fan of an enhanced cli approach. I don't want to have to navigate to the terminal and run a command, an extra step which I'll likely get tired of doing.

**Antigravity**: I have documented our discussion in `app/blog/posts/creating-a-custom-reading-list.mdx`.

Here is the breakdown of the "Connection" problem for Option 1 and the answers to your questions about Option 2.

### Solving the "Web Extension + Static Blog" Connection
You hit the nail on the head: *How do we connect a browser extension to a static site without a backend?*

The most elegant solution that fits your "widely available" and "no database" criteria is **The GitHub API Bridge**.

1.  **How it works:**
    *   The Chrome Extension asks the user for a **GitHub Personal Access Token** (stored securely in the browser).
    *   When you click "Add Reading", the extension uses the GitHub API to fetch the current `data/reading.json` from your repo.
    *   It appends the new link and thoughts.
    *   It pushes the updated file back to GitHub via the API.
    *   **Result:** GitHub detects the commit and your CI/CD (GitHub Actions) automatically rebuilds and deploys the site.

2.  **Why this is great:**
    *   **Zero Infrastructure:** No databases, no API servers, no running localhost.
    *   **Universal:** Works for anyone with a GitHub-hosted static site.
    *   **Portability:** You can add readings from *any* computer, not just your dev machine.

### Answering your questions on Option 2 (Raycast)

**"What would be the process for publishing this workflow?"**
Raycast has a "Store" (like an App Store) where you can publish extensions.
*   You would write a small script (React/Node.js) using the Raycast API.
*   You submit it to the Raycast Store.
*   Other users install it and configure it (likely pointing it to their local repo path or using the GitHub API method described above).

**"Wouldn't it be limited to only mac users?"**
**Yes.** Raycast is Mac-only. Alfred is Mac-only. This is the biggest downside if your goal is to make a tool for *everyone*. If the goal is just *your* productivity, it's the best tool. If you want to share this with the world, the Chrome Extension (Option 1) is the superior choice.

**Summary**
*   **For pure personal speed:** Raycast is unbeatable.
*   **For sharing with the world:** A Chrome Extension using the GitHub API is the "product" answer.

Which path appeals to you more now? I can draft the architecture for either.

**Me**: Nice, you THOUGHT you solved the issue by recommending the github API bridge but you missed a key issue, we are not marketing this solely to github users.
While this is still a great idea and something I did not know existed, I did mention that I may be transitioning away from github pages soon, so there would be no point in implementing a feature for it to be obsolete in a few days. Furthermore we wish to make this available to everyone who WANTS to have a reading log tracked on their site. Got it?

Maybe if we modify the web extension so that it knows where to write/append the latest read object to. And the user can handle the publication when they deploy the latest version of their site? Unless there isanother way.

As for the raycast option, I like it.

I think the main problem is how do we fully automate the entire reading cycle including the final step of updating our website wherever it may be hosted.

**Antigravity**: Now, to address your core question: **"How do we fully automate the entire reading cycle... wherever it may be hosted?"**

If we strip away the specific hosting provider (GitHub Pages, Vercel, Netlify, VPS), the one common denominator for almost all static sites is **Git**.

To "fully automate" this without a dedicated API server, the workflow must be:
1.  **Capture**: Get URL + Thoughts (via Extension or Raycast).
2.  **Write**: Append to the local `data/reading.json` file.
3.  **Sync**: Run `git commit` and `git push`.
4.  **Deploy**: The hosting provider detects the push and rebuilds.

### The "Local Write" Challenge
You suggested: *"Maybe if we modify the web extension so that it knows where to write/append... locally?"*

**The Problem:** Web Browsers (and Extensions) are sandboxed. They **cannot** silently write to your hard drive (e.g., `/Users/ossama/projects/blog/data/reading.json`) for security reasons. They can only download files to your Downloads folder.

**The Solution:**
To bridge this gap, we need a "Native Host". This is a tiny script installed on your computer that the Browser Extension is allowed to talk to.
1.  **Extension** sends message: `{ url: "...", thoughts: "..." }`
2.  **Native Host** (Node/Python script) receives message.
3.  **Native Host** writes to `reading.json`.
4.  **Native Host** runs `git push`.

### Why Raycast is the "Golden Path" here
Raycast **is** a native app. It already has permission to run scripts and edit files on your computer. It bypasses the entire "Sandbox" problem of the browser extension.

**The Ultimate "Universal" Workflow (Raycast Version):**
1.  **Trigger**: `Cmd + Space` -> "Log Reading".
2.  **Input**: Raycast grabs the active tab URL and asks for "Thoughts".
3.  **Action**: Raycast runs a script that:
    *   Reads `data/reading.json`.
    *   Adds the entry.
    *   (Optional) Runs `git add data/reading.json && git commit -m "New reading" && git push`.

This works for **any** static site, on **any** host, as long as you have the project on your machine.

**Shall we implement the Raycast script?** It solves every constraint you listed (no manual terminal, supports "thoughts", automates the update via Git).

**Me**: Hmm okay lets definitely detail the option for a web extension + specific hosting provider (GitHub Pages, Vercel, Netlify, VPS), it would be useful for people to know this.

We definitely do not want users to run a native host.

You're right the raycast option seems to be the best one, we should have a few commands cmd + r (unless already taken) for add to read list (prompts you with comment (optional) or date (optional)), and cmd + r + g or something so that you can also push it to git (when we first configure it we point it at the correct path for the script and reading.json). We'll expland more features out later for now lets just map out the mvp.

**Antigravity**: We definitely need a new Raycast extension project outside of this blog repo. Initialise it in a separate repository and configure everything you require, then proceed with the implementation of the MVP even if it means rewriting `scripts/add-reading.js` completely.

Remember to adhere to best practices as we intend to publish this repository on GitHub as well as publish the extension on the Raycast store.

We do need to find a way to bundle both the functionality of the Raycast extension AND the reading page on our blog as they go hand in hand. What would be the best way to do this?

**Antigravity**: The best architectural pattern here is **"The Extension as the Installer"**.

1.  **The Product is the Extension**: Users install the "Reading List Manager" from the Raycast Store.
2.  **Setup Command**: The extension includes a `Setup Blog` command.
    *   It asks: "Where is your Next.js blog?"
    *   It checks if `data/reading.json` exists. If not, it creates it.
    *   It checks if `app/reading/page.tsx` exists. If not, it **injects** the code for the reading page directly into their project (or copies a template).
3.  **Benefit**: The user doesn't need to clone two repos. They just install the Raycast extension, point it at their blog, and the extension "hydrates" their blog with the necessary UI code.

**Me**: Okay here you are in a new workspace, a clean slate, we have called the extension rlog (reading log, play on words blog shorterer yayayaya).

Proceed with the full implementation and also the mdx file blog post here as well.

I will be scrutinising your code thoroughly. Make me proud.

**Antigravity**: Initialized `rlog` project. Implemented:
*   `Log Read` command: Auto-fills URL, adds to JSON, pushes to Git.
*   `Setup Blog` command: Injects reading list code into Next.js app.

**Me**: Ooh I've noticed that after I submit the add reading form the "Thoughts" and "Date Added" sections don't refresh, they retain the prior submission.

Also we can think of a better more intuitive name than "Add Reading"

**Antigravity**: Fixed. Refactored to use `useForm` for proper resetting and added smart clipboard detection to pre-fill URLs. Renamed command to "Log Read".

**Me**: Not Log Article, make it "Log Read" or something.
Also why are there errors in `src/setup-blog.tsx` and `src/add-reading.tsx`?

Lets also brainstorm some other features that we could implement. Maybe a "Read Later" to add the current tab to a reading list.
A super feature 'Read Window Later' could be it goes through tab you have open on the current window determines if it is an article or post or hacker news discussion for example and saves it to the "Reading list", we may need a separate json for the reading list, reading_list.json. This may not be something we publish to github but something we do track locally and can view through raycast directly. Don't implement this yet, we're just thinking about possible extensions!

Maybe create a todo.txt file and add this and we can scope out a few other potential features.

Remember to continue to update `docs/creating-a-custom-reading-list.mdx` , we can be a bit more concise if we are just iterating on the same feature, each feature should be exhibited as a single prompt from me and response from you, leave out minor changes.

**Antigravity**: Addressed the errors by adding `import React from 'react'` and fixing indentation. Created `todo.txt` with the new feature ideas ("Read Later", "Read Window Later"). Updated the documentation to reflect the latest state.
